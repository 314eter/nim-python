from sage.rings.integer cimport Integer

cdef zero = Integer(0)
cdef one = Integer(1)
cdef two = Integer(2)

cpdef Integer nimsum(Integer a, Integer b):
    """Return the nim-sum of a and b."""
    return a ^ b

cdef dict expstable = dict()

cdef exps2(Integer n):
    """Rewrite n as the sum of products of fermatpowers.

    A list of lists of exponents is returned such that:
    n = sum(2**(sum(2**n for n in exps)) for exps in exps2(n))

    """
    cdef int l, i, j, mask
    if n in expstable:
        return expstable[n]
    exponents = []
    l = n.nbits()
    for i in range(l):
        if n.test_bit(i):
            exponent = []
            j = 0
            mask = 1
            while i >= mask:
                if i & mask:
                    exponent.append(j)
                j += 1
                mask <<= 1
            exponents.append(exponent)
    expstable[n] = exponents
    return exponents

cpdef Integer nimproduct(Integer a, Integer b):
    """Return the nim-product of a and b.

    Algorithm:
    - Rewrite a and b with exps2
    - Compute product with distributivuty of multiplication over addition.
      The resulting list of list of exponents f has the same property as exps2:
      a * b = sum(2**(sum(2**n for n in exps)) for exps in f)
    - Remove double terms (because a + a = 0)
    - Compute nim-product of each term (product of fermatpowers)
    - Compute nim-sum of terms

    """
    cdef Integer result = zero
    f = set()
    for l in exps2(a):
        for r in exps2(b):
            exps = tuple(sorted(l + r, reverse=True))
            if exps in f:
                f.remove(exps)
            else:
                f.add(exps)
    for exps in f:
        result ^= fermatproduct(exps)
    return result

cdef dict fermattable = dict()

cdef Integer fermatproduct(exps):
    """Return nim-product of one term (product of fermatpowers).

    Arguments:
    exps -- The exponents of the fermatpowers

    Algorithm:
    - Find least double exponent i in exps
    - If no doubles found, return 2**sum(2**n for n in exps)
    - Split exps in two list (a and b) without i, such that
      fermatproduct(exps) = fermatproduct(a) + fermatproduct(b)

    """
    cdef Integer result = zero
    cdef int i = len(exps) - 1
    while i > 0 and exps[i] != exps[i - 1]:
        i -= 1
    if i <= 0:
        for i in exps:
            result += two**i
        return two**result
    if exps in fermattable:
        return fermattable[exps]
    result = fermatproduct(exps[:i-1] + exps[i:])
    newexps = tuple(sorted(list(exps[:i-1] + exps[i+1:]) +
                    range(exps[i]-1, -1, -1), reverse=True))
    result ^= fermatproduct(newexps)
    fermattable[exps] = result
    return result

cpdef Integer nimpower(Integer a, Integer n):
    """Return the power a**n based on nim-multiplication.

    Arguments:
    a -- base
    n -- exponent

    Algorithm:
    Exponentiation by squaring

    """
    cdef Integer result = one
    cdef int i
    cdef size_t s
    s = mpz_sizeinbase(n.value, 2)
    for i from s > i >= 0:
        result = nimproduct(result, result)
        if mpz_tstbit(n.value, i):
            result = nimproduct(result, a)
    return result

cpdef Integer niminvert(Integer a):
    """Return the nim-multiplicative inverse of a.

    Algorithm:
    As described in Ex. 5 of "Nim Multiplication" by H. W. Lenstra

    """
    cdef Integer x, b = two
    if a == 1:
        return 1
    while b**2 <= a:
        b = b**2
    x = a // b
    return nimproduct((a ^ x), niminvert(nimproduct(a, a ^ x)))

